# cht_opt

Convex Hull Trick

Convex Hull Trick - оптимизация дп, позволяющая сделать из асимптотики О(n^2) асимптотику O(nlogn)
Оптимизация работает для дп вида dp[i] = min(dp[j] + b[j] * a[i])

Видно, что a[i] фиксировано для dp[i], изменяются только dp[j] и b[j]
Сделаем a[i] = x, b[j] = k, dp[j] = b
Получилось dp[i] = min(b + kx)
Т.е. dp[i] - это минимум по значениям всех линейных функций в точке x

Мы посчитали как-то dp[i], теперь нужно добавить эту функцию в какую-то структуру для подсчёта новых dp
Очевидно, что в каждой точке x нам выгодно хранить только функцию, значения которой минимально в этой точке
y = kx + b - прямая, поэтому будем хранить структуру из прямых
Пусть у нас уже есть какие-то прямые в структуре, сейчас мых хотим добавить ещё одну
Эта прямая как-то пересечёт уже имеющиеся прямые. Если прямая окажется ниже какой-то части прямых, то мы удалим всё, что выше новой прямой и скажем, что на этом отрезке минимальная функция - новая
Получается, что наша структура - это огибающая (выглядит, как кусочная функция с не более, чем одним, экстремумом)
Если в dp[i] min, то огибающая выгнута вверх, если max - вниз

Часто в задачах есть ограничения на b[j]: он возрастает/убывает
Предположим, что b[j] убывает. Это означает, что каждая новая прямая будет иметь меньший k, чем все предыдущие
Т.е. Новая прямая точно отсечёт какую-то часть структуры в конце

Как хранить прямые?
Прямые можно хранить просто в списке. Структуру можно хранить через точки пересечения прямых
Если пересечение новой прямой и последней прямой ниже, чем последнее пересечение прямых (мы рассматриваем случай с min), то последнюю прямую нужно удалить из структуры
Дальше нужно продолжить алгоритм. Т.е. мы пытаемся пересечь новую прямую с прямыми в конце, постепенно их удаляя
Это означает, что добавления прямой работает за O(n), ведь каждая прямая может только один раз добавиться и один раз удалиться

Как найти значение dp[i], если мы построили такую структуру?
Мы знаем точки пересечения прямых огибающей. Чтобы найти значение dp[i], мы должны найти, между какими точками лежит x
Это можно сделать бинпоиском

Т.е. итоговая асимптотика O(nlogn)

Решение задачи https://codeforces.com/contest/319/problem/C:
```cpp
#define ll long long
#define ld long double
#define all(a) (a).begin(), (a).end()
#define el '\n'
struct Line {
    int k, b; // kx + b
    Line() {}
    Line(int k_, int b_) {
        k = k_;
        b = b_;
    }
    int get_val(int x) {
        return k * x + b;
    }
};

vector<ld> points; // позиции пересечений прямых по x
vector<Line> cht; // массив с прямыми

ld cross(const Line& a, const Line& b) {
    return (ld)(b.b - a.b) / (ld)(a.k - b.k);
}

void add(const Line& l) {
    if (cht.empty()) {
        points.push_back(INT_MIN);
        cht.push_back(l);
        return;
    }
    while (cht.size() > 1) {
        ld cur = cross(cht.back(), l);
        if (cur <= points.back()) {
            points.pop_back();
            cht.pop_back();
        }
        else {
            break;
        }
    }
    points.push_back(cross(cht.back(), l));
    cht.push_back(l);
}

int get(int x) {
    int pos = lower_bound(all(points), x) - points.begin();
    return cht[pos - 1].get_val(x);
}

signed main() {
    int n;
    cin >> n;
    vector<ll> a(n);
    vector<ll> b(n);
    cin >> a >> b;
    vector<ll> dp(n, (ll)1e18);
    dp[0] = 0;
    add(Line(b[0], dp[0]));
    for (int i = 1; i < n; i++) {
        dp[i] = get(a[i]);
        add(Line(b[i], dp[i]));
    }
    cout << dp[n - 1] << el;
    return 0;
}
```

Если k возрастает, то для минимума мы будем добавлять не в конец, а в начало
Если мы ищем max, то при возрастании k - конец, при убывании - в начало

Если ограничение на монотонное изменение k нет, то можно поддерживать отсортированную структуру прямых (например, бинарное дерево поиска)
Тогда добавление прямой будет не с концов, а в любом месте структуры