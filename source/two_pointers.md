# two_pointers

Метод двух указателей

ВВЕДЕНИЕ

Метод двух указателей - метод, позволяющий решать задачи на массивах за линейное время. Указатели - это позиции в массиве/нескольких массивах.
Указатели всегда двигаются только вперёд, поэтому каждый из них может пройти значения 0 <= i <= n - 1 только один раз, что и даёт линейное время.

Код для понимания (указатели на двух массивах):
```cpp
int i = 0;
int j = 0;
while (i < n && j < m) {
    if (условие) {
        i++;
        // какой-то код
    }
    else {
        j++;
        // какой-то код
    }
    // какой-то код
}
```

Но проще использовать цикл for для одного из указателей (описано ниже). Также дальше будут рассмотрены несколько задач с применением метода двух указателей.

СЛИЯНИЕ МАССИВОВ

Для слияния двух отсортированных массивов будем поддерживать указатель на каждом массиве. Каждый раз будем сравнивать элементы на позициях указателей.
Если элемент первого массива меньше, то добавляем его в новый массив и сдвигаем указатель.
Иначе добавляем в новый массив элемент из второго массива и сдвигаем второй указатель.

Такой алгоритм будет продолжаться, пока один из массивов не закончится.
Если один из массивов закончился, то нужно просто добавить все оставшиеся элементы из второго массива.

ЧИСЛО МЕНЬШИХ

Есть массивы A и B. Для каждого B_j хотим узнать кол-во A_i, таких что A_i < B_j. Для начала отсортируем массивы.
Теперь сделаем такое же слияние, только не будет строить новый массив (будет только менять указатели).
Если при сравнении элемент из первого массива оказался меньше, то просто увеличим первый указатель.
Иначе получаем ответ для позиции указателя второго массива (он равен значению первого указателя). После этого увеличиваем второй указатель.

Можно не писать один while с несколькими условиями, а сделать for для первого указателя и while внутри для второго.
Мы двигаем первый указатель и двигаем второй указатель, пока выполняется условие.

```cpp
int i = 0;
for (int j = 0; j < n; j++) {
    while (i < m && a[i] < b[j]) {
        i++;
    }
    res[j] = i;
}
```

ОТРЕЗОК С НУЖНОЙ СУММОЙ

Есть массив A и число S. Нужно найти максимальный по длине подмассив, такой что сумма элементов на нём не больше S и его длина максимальна.

Сделаем два указателя на одном массиве.
Первый указатель L будет отвечать за левую границу текущего подмассива, а второй указатель R - за правую границу подмассива.

Сдвинем R вправо. Могло получиться два случая:
1) Сумма на текущем подмассиве осталась не больше S. Тогда ничего больше делать не надо.
2) Сумма стала больше S. Теперь нужно двигать указатель L вправо, пока сумма снова не станет не больше S.

```cpp
int L = 0;
int x = 0; // сумма на текущем подмассиве
for (int R = 0; R < n; R++) {
    x += A[R];
    while (x > S) {
        x -= A[L];
        L++;
    }
    res = max(res, R - L + 1);
}
```

Второй вариант этой задачи - найти подмассив минимальной длины, сумма элементов которого не меньше S.

Решение очень похоже, только нужно изменить условие и добавить проверку, что для границы R существует ответ.

```cpp
int L = 0;
int x = 0; // сумма на текущем подмассиве
for (int R = 0; R < n; R++) {
    x += A[R];
    while (x - A[L] >= S) {
        x -= A[L];
        L++;
    }
    if (x >= S) {
        res = min(res, R - L + 1);
    }
}
```

Третий вариант задачи - нужно найти кол-во подмассивов, таких что сумма на каждом их них не больше S.

Эта задача решается так же, как первый вариант, только мы теперь будем обновлять ответ не максимальной длиной, а суммой всех длин таких подмассивов.
Почему так? Если мы нашли подмассив с суммой не больше S, то и все суффиксы этого подмассива тоже имеют сумму не больше S, а кол-во суффиксов равно длине подмассива.

```cpp
int L = 0;
int x = 0; // сумма на текущем подмассиве
for (int R = 0; R < n; R++) {
    x += A[R];
    while (x > S) {
        x -= A[L];
        L++;
    }
    res += R - L + 1;
}
```

УНИВЕРСАЛЬНОЕ РЕШЕНИЕ ДЛЯ ОТРЕЗКОВ

Задачи с суммой - это лишь частный случай задач на отрезки.
Классическая задача звучит так: нужно найти (максимальный по длине отрезок/минимальный по длине) хороший отрезок или кол-во хороших отрезков.

Такую задачу можно решить методом двух указателей, если выполняются условия:
1) Любой вложенный в хороший отрезок также является хорошим (тогда можно применить алгоритм, как в первой задаче).
Либо любой отрезок, содержащий хороший отрезок, тоже должен быть хорошим (тогда можно применять алгоритм из второй задачи)
2) Можно как-то пересчитывать функцию для отрезка при движении указателей

Если условия выполняются, то задачу можно решить двумя указателями. Для этого нужны реализации функций add, remove и good.

add() добавляет элемент в конец текущего отрезка и пересчитывает функцию.

remove() удаляет элемент из начала текущего отрезка и пересчитывает функцию.

good() проверяет, является ли текущий отрезок хорошим.

Тогда код будет выглядеть так (для решения первой задачи):

```cpp
int L = 0;
for (int R = 0; R < n; R++) {
    add(A[R]);
    while (!good()) {
        remove(A[L]);
        L++;
    }
    // пересчёт ответа
}
```

ОТРЕЗОК С НЕБОЛЬШИМ МНОЖЕСТВОМ

Есть массив A и число K. Хотим найти наибольший по длине подмассив, на котором не более K различных чисел.

Для решения заведём массив (или map, если числа большие) cnt, где cnt_i - сколько чисел равных i на текущем отрезке.
Также будем хранить переменную num, которая будет хранить, сколько различных чисел на отрезке.

Функция good пишется просто:
```cpp
bool good() {
    return num <= k;
}
```

Когда мы добавляем новый элемент x в отрезок, то мы должны увеличить cnt для этого элемента.
Если cnt_x был до этого равен 0, то кол-во различных чисел увеличилось, поэтому нужно увеличить num.

```cpp
void add(int x) {
    if (cnt[x] == 0) {
        num++;
    }
    cnt[x]++;
}
```

То же самое с remove

```cpp
void remove(int x) {
    cnt[x]--;
    if (cnt[x] == 0) {
        num--;
    }
}
```

ОТРЕЗОК С НЕБОЛЬШИМ РАЗБРОСОМ

Хотим найти максимальный по длине подмассив, на котором X_max - X_min <= K.

Для решения этой задачи понадобится очередь на двух стеках, чтобы корректно пересчитывать значения минимума и максимума при удалении и добавлении элементов в текущий отрезок.

У нас будет два стека s_1 и s_2, которые будут ориентированы в разные стороны.
Может получиться, что мы удалили весь стек s_1, тогда мы можем переложить все элементы из s_2 в s_1.

Нам нужно поддерживать минимум и максимум на двух стеках. Для этого для каждого стека понадобятся ещё два стека: стек минимумов и стека максимумов.
Например, стек s_1 = [3, 5, 2, 6], тогда стек минимумов такой: s_1min = [3, 3, 2, 2], стек максимумов такой: s_1max = [3, 5, 5, 6].

С таким стеком легко можно делать требуемые операции.
Мы можем узнать текущий максимум и минимум, посмотрев на верхние значения стека максимумов и стека минимумов.
Можем добавить число x, добавив в основной стек само число, в стек минимумов min(s_min.top(), x), в стек максимумов max(s_max.top(), x).
Можем удалить число, просто удалив верхнее значение во всех трёх стеках.

Полное решение этой задачи:

```cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define el '\n'
template <class T> istream& operator >>(istream& in, vector<T>& arr) {for (T& i: arr) in >> i; return in;}

struct Stack {

    vector<ll> s, smin, smax;

    void push(ll x) {
        s.push_back(x);
        if (smin.empty()) {
            smin.push_back(x);
        }
        else {
            smin.push_back(::min(x, smin.back()));
        }

        if (smax.empty()) {
            smax.push_back(x);
        }
        else {
            smax.push_back(::max(x, smax.back()));
        }
    }

    ll pop() {
        ll res = s.back();
        s.pop_back();
        smin.pop_back();
        smax.pop_back();
        return res;
    }

    bool empty() {
        return s.empty();
    }

    ll min() {
        if (smin.empty()) {
            return LONG_LONG_MAX;
        }
        return smin.back();
    }

    ll max() {
        if (smax.empty()) {
            return LONG_LONG_MIN;
        }
        return smax.back();
    }
};

Stack s1, s2;
ll K;

void add(ll x) {
    s2.push(x);
}

void remove() {
    if (s1.empty()) {
        while (!s2.empty()) {
            s1.push(s2.pop());
        }
    }
    s1.pop();
}

bool good() {
    ll Max = max(s1.max(), s2.max());
    ll Min = min(s1.min(), s2.min());
    return Max - Min <= K;
}

void solve() {
    int n;
    cin >> n >> K;
    vector<ll> a(n);
    cin >> a;

    int L = 0;
    ll res = 0;
    for (int R = 0; R < n; R++) {
        add(a[R]);
        while (!good()) {
            remove();
            L++;
        }
        res += R - L + 1;
    }
    cout << res << el;
}

signed main() {
    solve();
    return 0;
}
```

Указателей может быть больше двух, тогда добавляются циклы while в цикле for (один указатель - один цикл while)