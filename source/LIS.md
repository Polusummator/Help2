# LIS

Наибольшая возрастающая подпоследовательность

НВП - это подпоследовательность массива, элементы которой возрастают

Искать НВП можно при помощи дп
Первое решение работает за O(n^2)
В dp[i] будем хранить длину НВП, заканчивающейся в этом элементе
Тогда пересчёт простой: пройдём по всем j < i, если a[j] < a[i], то обновим ответ через dp[j]
Из всех таких ответов возьмём максимальный

```cpp
int n;
cin >> n;
vector<int> a(n);
cin >> a;
vector<int> dp(n, 1);
vector<int> p(n, -1);
for (int i = 0; i < n; i++) {
    for (int j = 0; j < i; j++) {
        if (a[i] > a[j] && dp[j] + 1 > dp[i]) {
            dp[i] = dp[j] + 1;
            p[i] = j;
        }
    }
}
// make answer
int cur = max_element(dp.begin(), dp.end()) - dp.begin();
vector<int> ans;
while (cur != -1) {
    ans.push_back(a[cur]);
    cur = p[cur];
}
reverse(ans.begin(), ans.end());
cout << ans << el;
```

Но задачу можно решить за O(nlogn)
Изменим значение, которое хранит дп
Теперь dp[i] - наименьший элемент, на который заканчивается возрастающая последовательность длины i
Что это даёт? Последний элемент текущей НВП говорит нам о том, какой элемент можно поставить следующим
Чем меньше последний элемент, тем больше элементов мы сможем поставить дальше
Изначально dp[0] = -INF, потому что после -INF можно поставить любой элемент
НВП длины > 0 у нас пока нет, поэтому все остальные элементы равны INF (после INF нельзя ничего поставить)

Чтобы понять алгоритм, можно рассмотреть пример:
a = [2, 3, 1, 4, 2, 6, 6, 9, 5]
Изначально dp = [-INF, INF, INF, INF, INF, INF, INF, INF, INF, INF]
1. Мы рассмотрели a[0] = 2, у нас появилась последовательность длины 1
dp = [-INF, 2, INF, INF, INF, INF, INF, INF, INF, INF]
2. Рассмотрели a[1] = 3, появилась ВП длины 2 - [2, 3]
dp = [-INF, 2, 3, INF, INF, INF, INF, INF, INF, INF]
3. Рассмотрели a[2] = 1, обновилось значение dp[1]
dp = [-INF, 1, 3, INF, INF, INF, INF, INF, INF, INF]
4. Рассмотрели a[3] = 4
dp = [-INF, 1, 3, 4, INF, INF, INF, INF, INF, INF]
5. Рассмотрели a[4] = 2
dp = [-INF, 1, 2, 4, INF, INF, INF, INF, INF, INF]
6. Рассмотрели a[5] = 6
dp = [-INF, 1, 2, 4, 6, INF, INF, INF, INF, INF]
7. Рассмотрели a[6] = 6
dp = [-INF, 1, 2, 4, 6, INF, INF, INF, INF, INF]
8. Рассмотрели a[7] = 9
dp = [-INF, 1, 2, 4, 6, 9, INF, INF, INF, INF]
9. Рассмотрели a[8] = 5
dp = [-INF, 1, 2, 4, 5, 9, INF, INF, INF, INF]

Заметим, что при появлении нового числа в dp меняется не больше 1 значения (либо мы обновляем dp[1], либо добавляем новое число в конец какой-то подпоследовательности)
Второе важное свойство - в dp все значения всегда возрастают (потому что нельзя сделать бОльшую последовательность с меньшим последним элементом)
При каждой итерации хотим найти наибольшую последовательность, куда мы можем поставить новый элемент
Это делается при помощи бинпоиска

Если хотим искать наибольшую неубывающую последовательность, то нужно изменить бинпоиск (искать последнее вхождение, т.е. upper_bound())

Теперь нужно восстановить ответ
Используем предков. Мы добавляем элемент после наибольшего элемента, который меньше нашего, поэтому предок и есть этот элемент
Но в dp лежат числа, а мы хоти знать индексы, поэтому создадим массив index[i], параллельный dp
Если в dp[i] лежит a[j], то в index[i] лежит j

```cpp
int INF = 1e9;
int n;
cin >> n;
vector<int> a(n);
cin >> a;
vector<int>dp(n + 1, INF);
vector<int>index(n + 1, -1);
vector<int>p(n, -1);
dp[0] = -INF;
for (int i = 0; i < n; i++) {
    int pos = lower_bound(dp.begin(), dp.end(), a[i]) - dp.begin();
    p[i] = index[pos - 1];
    dp[pos] = a[i];
    index[pos] = i;
}
// make answer
for (int i = n; i >= 0; --i) {
    if (dp[i] != INF) {
        int cur = index[i];
        vector<int> ans;
        while (cur != -1) {
            ans.push_back(a[cur]);
            cur = p[cur];
        }
        reverse(ans.begin(), ans.end());
        cout << ans << el;
        return 0;
    }
}
```