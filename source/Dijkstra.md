# Dijkstra

Алгоритм Дейкстры

Алгоритм Дейкстры - это алгоритм поиска кратчайших путей от начальной вершины до всех остальных во взвешенном графе

Описание:
Ответы для всех вершин будем хранить в массиве d
Сначала все элементы d заполнены INF (большое число), кроме стартовой (s), d[s] = 0
Каждую итерацию мы ищем непосещённую вершину с минимальным d[j] (v)
После этого мы пытаемся обновить ответы для всех смежных вершин (минимум из d[смежная_вершина] и d[v] + длина_ребра)

Также можно восстановить пути до вершин
Для этого при обновлении ответов для смежных вершин будем присваивать p[смежная_вершина] = v
После нужно будет пройтись от конечной вершины по предкам до начальной и развернуть полученный путь

Можно не перебирать каждый раз вершину с наименьшим расстоянием, а использовать структуру, которая делает это автоматически - set
Такой способ будет работать быстрее (кроме случая с полными графами - в полных графах лучше просто циклом искать вершину)
```cpp
int n, start, finish;
cin >> n >> start >> finish;
start--;
finish--;
vector<vector<pair<int, int>>> g(n);
vector<int> p(n, -1);
// Ввод графа (первое значение в паре - вершина, второе - вес)
vector<int> d(n, INF);
d[start] = 0;
set<pair<int, int>> s;
s.insert({0, start});
while (!s.empty()) {
    int v = s.begin()->second;
    s.erase(s.begin());
    for (auto i: g[v]) {
        int u = i.first;
        int w = i.second;
        if (d[u] > d[v] + w) {
            s.erase({d[u], u});
            d[u] = d[v] + w;
            p[u] = v;
            s.insert({d[u], u});
        }
    }
}
if (d[finish] == INF) {
    cout << "-1\n";
    return 0;
}
cout << d[finish] << el;
vector<int> path;
for (int v = finish; v != start; v = p[v])
    path.push_back(v + 1);
path.push_back(s + 1);
reverse(path.begin(), path.end());
cout << path << el;
```
