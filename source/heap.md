# heap

Куча

Куча - структура данных, позволяющая добавлять элементы, находить минимум/максимум всех элементов, удалять минимум/максимум

Куча - это дерево из чисел, в котором выполняется условие: число в родителе меньше или равно чисел в детях (для кучи на минимум)
Для кучи на максимум условие: число в родителе больше или равно чисел в детях

1. Поиск минимума/максимума
Минимум/максимум - это вершина кучи

2. Добавление
Добавим требуемое число в конец дерева (мы храним кучу на массиве, как дерево отрезков)
Но условие кучи могло нарушиться, поэтому будем применять операцию проталкивания наверх: если условие для родителя и ребёнка не выполнено, поменяем их местами, и продолжим для родителя

3. Удаление минимума/максимума
Хотим удалить корень. Тогда присвоим корню значение последнего элемента кучи, и уменьшим размер кучи на один (для массива сделаем pop)
Теперь нужно восстановить условие кучи. Будем проталкивать вниз
Для кучи на минимум: берём минимального сына (понятно, что сыновей может быть 0, 1 или 2), и если с ним условие не выполнено, меняем родителя с ним и продолжаем алгоритм для этого сына
Для кучи на максимум разница только в том, что мы берём максимального сына

Реализация (на минимум):

```cpp
# Чтобы поменять на кучу на максимум, достаточно изменить в heap_condition на >=, в compare_sons на max
def heap_condition(par_num, v_num):
    return par_num <= v_num


def compare_sons(son1, son2):
    return min(son1, son2)


class Heap:
    def __init__(self):
        self.__a = []

    def go_down(self, v):
        while v * 2 + 1 < len(self.__a):
            go_to = v * 2 + 1
            if v * 2 + 2 < len(self.__a) and compare_sons(self.__a[v * 2 + 2], self.__a[go_to]) == self.__a[v * 2 + 2]:
                go_to = v * 2 + 2
            if not heap_condition(self.__a[v], self.__a[go_to]):
                self.__a[v], self.__a[go_to] = self.__a[go_to], self.__a[v]
                v = go_to
            else:
                break

    def go_up(self, v):
        while v:
            par = (v + 1) // 2 - 1
            if not heap_condition(self.__a[par], self.__a[v]):
                self.__a[par], self.__a[v] = self.__a[v], self.__a[par]
                v = par
            else:
                break

    def get_top(self):
        return self.__a[0]

    def add(self, val):
        self.__a.append(val)
        self.go_up(len(self.__a) - 1)

    def remove_top(self):
        self.__a[0] = self.__a[-1]
        self.__a.pop()
        self.go_down(0)
```

Пмирамидальная сортировка
Кучу можно использовать для сортировки массива. Для этого достаточно создать кучу на минимум, добавить в неё все элементы массива и по одному вытаскивать минимум из кучи. Последовательность вытащенных минимумов будет отсортированным массивом
