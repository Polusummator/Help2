# euler

Эйлеровость

Эйлеров путь - путь в графе, проходящий по всем рёбрам один раз
Эйлеров цикл - эйлеров путь, начинающийся и заканчивающийся в одной вершине

Условие существования эйлерова пути: степени всех вершин чётные или есть две вершины с нечётными степенями
Условие существования эйлерова цикла: степени всех вершин чётные

Для ориентированных графов:
Цикл есть, если условие "кол-во рёбер, входящих в вершину равно кол-во рёбер исходящих из вершины" выполняется для всех вершин
Путь есть, если выполняется условие для всех вершин, кроме двух: у одной кол-во входящих рёбер больше кол-ва исходящих на 1, у второй наоборот

Для построения пути будем просто ходить по рёбрам графа ровно по одному разу
Для этого заведём массив first[v], в котором будет храниться индекс первого непосещённого ребра из данной вершины
Конечно, если есть две вершины с нечётными степенями, нужно запускать алгоритм из одной из них
В конце каждого запуска алгоритма (для одной вершины) добавляем вершину в ответ, потому что мы прошли все рёбра из этой вершины и больше в неё не вернёмся
Для ориентированных графов нужно запускаться из вершины, у которой кол-во исходящих рёбер больше кол-ва входящих (если такая есть, иначе из любой вершины)
Также в ориентированном графе в конце нужно развернуть путь

Код:
```cpp
struct Edge {
    int u;
    int index;

    Edge() {}
    Edge(int u_, int index_) {
        u = u_;
        index = index_;
    }
};

vector<vector<Edge>> graph;
vector<bool> used;
vector<int> first;
vector<int> ans;

void euler(int v) {
    while (first[v] < graph[v].size()) {
        int i = first[v];
        int u = graph[v][i].u;
        int e = graph[v][i].index;
        first[v]++;
        if (!used[e]) {
            used[e] = true;
            euler(u);
        }
    }
    ans.push_back(v + 1);
}
```

ПОКРЫТИЕ НЕОРИЕНТИРОВАННОГО ГРАФА МИНИМАЛЬНЫМ КОЛ-ВОМ ПУТЕЙ
Для покрытия путями для начала найдём все вершины с нечётными степенями
Соединим их в пары (мы нашли 4 вершины, проведём рёбра 1 - 2 и 3 - 4)
Запишем эти пары куда-нибудь
Теперь построим эйлеров цикл (мы можем это сделать, потому что все степени вершин чётные)
Разобьём цикл по рёбрам, которые мы добавили в начале
Мы получаем пути. Надо не забыть склеить последний путь с первым (потому что это один путь)
Единственная проблема заключается в том, что мы можем разрезать по рёбрам, которые были в графе изначально
Пример - граф отрезок. После считывания мы добавим КРАТНОЕ ребро, соединяя две вершины с нечётными степенями
Избежать это можно, храня кол-во рёбер между двумя соседними вершинами (мы должны разрезать только одно ребро)

Код функции main (не претендует на идеальность, работает не особо быстро из-за map):
```cpp
signed main() {
    int n, m;
    cin >> n >> m;
    map<pair<int, int>, int> edges;
    graph.resize(n);
    first.resize(n);
    for (int i = 0; i < m; i++) {
        int v, u;
        cin >> v >> u;
        v--;
        u--;
        graph[v].push_back(Edge(u, i));
        graph[u].push_back(Edge(v, i));
        edges[{v, u}]++;
        edges[{u, v}]++;
    }
    vector<int> n_vertex;
    map<pair<int, int>, bool> to_del;
    for (int i = 0; i < n; i++) {
        if (graph[i].size() % 2) {
            n_vertex.push_back(i);
        }
    }
    int cnt_edges = m;
    for (int i = 1; i < n_vertex.size(); i += 2) {
        int v = n_vertex[i - 1];
        int u = n_vertex[i];
        graph[v].push_back(Edge(u, cnt_edges));
        graph[u].push_back(Edge(v, cnt_edges));
        cnt_edges++;
        to_del[{v + 1, u + 1}] = true;
        to_del[{u + 1, v + 1}] = true;
        edges[{v, u}]++;
        edges[{u, v}]++;
    }
    used.resize(cnt_edges);
    euler(0);
    vector<vector<int>> paths;
    paths.push_back({ans[0]});
    for (int i = 1; i < ans.size(); i++) {
        if (to_del.find({ans[i], ans[i - 1]}) != to_del.end()) {
            if (edges[{ans[i] - 1, ans[i - 1] - 1}] <= 1) {
                paths.push_back({});
            }
            paths[paths.size() - 1].push_back(ans[i]);
            edges[{ans[i] - 1, ans[i - 1] - 1}]--;
            edges[{ans[i - 1] - 1, ans[i] - 1}]--;
        }
        else {
            paths[paths.size() - 1].push_back(ans[i]);
        }
    }
    if (paths.size() > 1) {
        cout << paths.size() - 1 << el;
        for (int i : paths.back()) {
            cout << i << ' ';
        }
        for (int i = 1; i < paths[0].size(); i++) {
            cout << paths[0][i] << ' ';
        }
        cout << el;
        for (int i = 1; i < paths.size() - 1; i++) {
            for (int j : paths[i]) {
                cout << j << ' ';
            }
            cout << el;
        }
    }
    else {
        cout << "1\n";
        for (int i : paths[0]) {
            cout << i << ' ';
        }
        cout << el;
    }
    return 0;
}
```

