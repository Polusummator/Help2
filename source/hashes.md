# hashes

Хэши

Идеальный хеш - это тот хеш, который удовлетворяет равенствам:
x = y => H(x) = H(y)
x ≠ y => H(x) ≠ H(y)
Но представленный ниже алгоритм - это неидеальный хеш

Один из алгоритмов хеширования:
Присутствуют два параметра: p и mod
p <= 300
mod ** 2 должен влезать в long long и желательно быть простым числом
популярные mod: 10 ** 9 + 7; 10 ** 9 + 9; 2 * 10 ** 9 + 11
но популярные mod лучше не использовать
Также лучше в начале программы выбирать параметры из списка, используя random

Номер каждого элемента в ASCII умножается на соответствующую степень числа p, затем произведения складываются, и находится остаток от деления на mod
Example:
```H('abac') = (ord('a') * p ** 3 + ord('b') * p ** 2 + ord('a') * p ** 1 + ord('c')) % mod```

Но, т.к. данный хеш неидеален, можно делать двойной, тройной и т.д. хеш (делать к одной строке несколько хешей с разными p и mod)

Код такого хеширования на C++:
```cpp
long long getHash(const string& s, int p, long long mod) {
    long long H = 0;
    for (auto& c : s) {
        H = (H * p + c) % mod;
    }
    return H;
}
```

Гораздо полезнее хранить хеши префиксов строки. Код на C++:
```cpp
vector <long long> getHash(const string& s, int p, long long mod) {
	vector<long long> ans(s.size());
	ans[0] = s[0];
	for (size_t i = 1; i < s.size(); ++i) {
		ans[i] = (ans[i - 1] * p + s[i]) % mod;
	}
	return ans;
}
```

Благодаря нахождению хешей префиксов, можно искать хеши подстрок
Код:
```cpp
long long subHash(int l, int r, long long mod) {
	long long big = H[r];
	long long small = 0;
	if (l != 0) {
		small = (H[l - 1] * st[r - l + 1]) % mod;
	}
	return (big - small + mod) % mod;
}
```
st - список степеней p, H - список хешей префиксов

Про двойное хеширование:
Двойной хеш - это пара двух значений хеша с разными p и mod (список пар)
Все действия производятся не с числами, а с парами
Пример двойного хеширования:

```cpp
const ll p1 = 179, Mod1 = 556556107;
const ll p2 = 139, Mod2 = 2e9 + 11;
vector<ll> powers1;
vector<ll> powers2;

vector<pair<ll, ll>> getHash(const string& s) {
    vector<pair<ll, ll>> h(s.size());
    h[0].first = s[0];
    h[0].second = s[0];
    for (int i = 1; i < s.size(); i++) {
        h[i].first = (h[i - 1].first * p1 + s[i]) % Mod1;
        h[i].second = (h[i - 1].second * p2 + s[i]) % Mod2;
    }
    return h;
}

pair<ll, ll> subHash(int l, int r, const vector<pair<ll, ll>>& h) {
    pair<ll, ll> big = h[r];
    pair<ll, ll> small = {0, 0};
    if (l > 0) {
        small.first = (h[l - 1].first * powers1[r - l + 1]) % Mod1;
        small.second = (h[l - 1].second * powers2[r -l + 1]) % Mod2;
    }
    pair<ll, ll> res;
    res.first = (big.first - small.first + Mod1) % Mod1;
    res.second = (big.second - small.second + Mod2) % Mod2;
    return res;
}
```

Также хеширование обобщается на бОльшие размерности
Например, можно считать хеши подпрямоугольников
Для этого нужен свой p для каждого измерения
При переходе от одного столбца к другому умножаем на один p, при переходе по строкам - на другой

Код:
```py
p_n = 179
p_m = 227
mod = int(1e9 + 7)

def get_hash(s):
    n = len(s)
    m = len(s[0])
    h = [[0] * m for i in range(n)]
    h[0][0] = ord(s[0][0])
    for i in range(1, n):
        h[i][0] = (h[i - 1][0] * p_n + ord(s[i][0])) % mod
    for j in range(1, m):
        h[0][j] = (h[0][j - 1] * p_m + ord(s[0][j])) % mod
    for i in range(1, n):
        for j in range(1, m):
            h[i][j] = ((h[i - 1][j] * p_n) % mod + (h[i][j - 1] * p_m) % mod + ord(s[i][j]) - (p_n * p_m * h[i - 1][j - 1]) % mod + mod) % mod
    return h

def sub_hash(h, x1, y1, x2, y2): # (x1, y1) - левый верхний, (x2, y2) - правый нижний
    res = h[x2][y2]
    if x1 > 0:
        res -= (h[x1 - 1][y2] * pows_n[x2 - x1 + 1]) % mod
    if y1 > 0:
        res -= (h[x2][y1 - 1] * pows_m[y2 - y1 + 1]) % mod
    if x1 > 0 and y1 > 0:
        res += (h[x1 - 1][y1 - 1] * pows_n[x2 - x1 + 1] * pows_m[y2 - y1 + 1]) % mod
    return (res + 2 * mod) % mod

n, m = [int(i) for i in input().split()]
s = [''] * n
for i in range(n):
    s[i] = input()
pows_n = [0] * (n + 1)
pows_m = [0] * (m + 1)
pows_n[0] = 1
pows_m[0] = 1
for i in range(1, n):
    pows_n[i] = (pows_n[i - 1] * p_n) % mod
for i in range(1, m):
    pows_m[i] = (pows_m[i - 1] * p_m) % mod
h = get_hash(s)
```

Что можно делать с хешами:
1. Можно найти подстроку в строке (найти её хеш и посмотреть все хеши подстрок такой же длины)

1. Найти циклический сдвиг
    Дано две строки. Вторая - циклический сдвиг первой
    n - длина строки, k - сдвиг
    Можно умножить первую строку на две, тогда она будет выглядеть так:
    n - k   k   n - k   k
    Вторая строка выглядит так:
    k   n - k
    Теперь можно найти вхождение второй строки в первую

1. Проверка подстроки на палиндром
    Для этого нужно найти хеш подстроки и её обратный хеш (хеш перевёрнутой строки)
    После этого проверить равенство хешей

1. Проверка на период (можно ли разбить на одинаковые блоки длиной k)
    Сначала нужно проверить, делится ли длина строки на k
    Дальше нужно сравнить хеши строк от второго до последнего блока и от первого до предпоследнего
    s[:n - k] и s[k + 1:]

1. Минимальный период строки
    Нужно разложить длину строки на множители и увеличивать значение, пока строка является периодом (делить на всё большее значение)

1. Сравнение строк
    Нужно найти самый большой общий префикс, а потом сравнить символы после него
    Длину префикса можно найти бинпоиском

1. Поиск подпалиндромов
    Палиндром может быть нечётной длины (центр - символ) и чётной (центр между символами)
    Можно пройти по строке, смотря на символы и промежутки между символами. Таким образом мы перебираем центр палиндрома
    От каждого центра мы будем расширять строку, пока эта строка является палиндромом (проверка делается хешами)

    Но поиск палиндромов можно осуществить быстрее, проще и без хешей с использованием Алгоритма Манакера
    (раздел Manacher)

1. Поиск наибольшей общей подстроки
    Посчитаем хеши двух строк
    Теперь сделаем бинпоиск по длине общей подстроки
    Для каждого значения m бинпоиска пройдём сначала по первой строке и положим все хеши подстрок длины m в map
    Теперь пройдём по хешам подстрок длины m второй строки и посмотрим, есть ли какие-то из них в map

1. z-функция
    z-функция - это поиск максимального числа l, такого, что подстрока, начинающаяся в i и длиной l, равна префиксу длины l
    l можно искать бинпоиском, а сравнивать строки - хешами
    Но z-функцию можно написать проще и без хешей
    (раздел z_function)

1. По строке можно построить дерево хешей (описано в segment_tree)
    Такое дерево позволяет делать операции с хешами и изменять элементы строки
