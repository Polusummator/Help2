# fractional_cascading

Частичное каскадирование

Пусть нужно найти кол-во чисел, меньших заданного числа X в K массивах
Это можно сделать бинпоиском в каждом массиве за O(Klogn), где n - кол-во чисел в одном массив
Это решение можно ускорить до O(K + logn), используя технику частичного каскадирования

ДВА МАССИВА
Мы хотим взять один массив и сделать бинпоиск на нём, найдя ответ сразу на всех массивах
Пусть у нас есть два массива (A и B). Бинпоиск мы будем производить на массиве A
Возьмём каждый второй элемент массива B и добавим его в массив A. Конечно, массив должен остаться отсортированным

Пример:
A = [1, 7, 45, 202]
B = [3, 6, 60, 310]
После добавления массив A будет выглядеть так:
$A = [1, <3>, <6>, 7, 45, <60>, 202, <310>]
Выделены добавленные элементы

Теперь мы можем запустить бинпоиск на массиве A
Для найденной позиции мы можем сказать ближайшие числа из второго массива
Но так как мы добавляли каждое второе число из второго массива, осталось только проверить, больше ли X числа, которое находится между двумя ближайшими числами из второго массива

Есть вопрос, как находить индексы ближайших чисел во втором массиве. Для этого можно хранить в массивах тройки чисел:
1. Само число
2. Номер массива, из которого взято это число
3. Индекс числа в массиве, из которого оно взято

Используя такие тройки, мы можем предпосчитать для каждой позиции в массиве A ближайшие числа из массива B

K МАССИВОВ
Для случая с K массивами решение похоже на решение для двух массивов
Теперь мы будем класть элементы из каждого массива в предыдущий массив
Сначала добавляем каждый второй элемент из последнего массива в предпоследний
После этого из полученного предпоследнего массива добавляем каждый второй элемент в следующий массив и т.д.

При таком каскадировании первый массив не "разрастётся". Это можно доказать
В лучшем случае из массива K в массив K - 1 будет добавлено n/2 элементов из последнего массива,
из массива K - 1 в массив K - 2 будет добавлено n / 4 элементов из последнего массива,
из массива K - 2 в массив K - 3 будет добавлено n / 8 элементов и т.д.
Сумма всех таких значений не больше 2n. Т.е. первый массив вырастет не более, чем в 2 раза

Как найти ответ? Для каждой позиции в каждом массиве предпосчитаем ближайшие элементы из предыдущего массива
Запускаем бинпоиск в первом массиве, находим в нём ближайшие элементы их второго массива
Находим число между ними и сравниваем с числом X. Теперь у нас есть новая позиция X, продолжаем делать то же самое

Важно, что тройки чисел должны меняться при добавлении к следующему массиву, иначе мы не сможем правильно выбрать позиции чисел
При добавлении элементов к следующему массиву, эти тройки чисел в новом массиве начинают хранить информацию только о предыдущем массиве (даже если они остались ещё от последнего массива)
Тройки чисел нужны только для предпосчёта, в самом алгоритме их использовать не получится, иначе асимптотика станет намного хуже

Итого, мы запустили бинпоиск на первом массиве и сделали K спусков по массивам. Асимптотика равна O(K + logn)