# dfs

DFS - поиск в глубину

dfs - это стандартный обход графа

```py
void dfs(int v, int d = 0) {
    used[v] = true;
    depth[v] = d;
    for (int u : g[v]) {
        if (!used[u]) {
            dfs(u, d + 1);
        }
    }
}
```

Обычно dfs используется для прохода по графу и подсчёта какого-нибудь дп, функции и т.д.

Некоторые задачи:
1. Раскраска графа в 2 цвета
   Граф можно раскрасить в 2 цвета, если он двудолен
   Эту задачу можно решить жадным алгоритмом (просто попробовать раскрасить в 2 цвета)
   Если мы встречаем вершину, которая уже покрашена, а сейчас мы знаем, что она должна быть покрашены в другой цвет, то граф не двудолен (есть цикл нечётной длины)
2. Нахождение цикла в неориентированном графе
   Чтобы найти цикл можно запустить dfs
   Если мы находим вершину, которая уже посещена, и мы не пришли из неё, то цикл найден
3. Нахождение цикла в ориентированном графе
   Красим граф в 3 цвета:
   Заходим в вершину, её цвет равен 1
   Проходим по всем смежным вершинам
   Если цвет смежной вершины равен 0, то запускаем dfs из неё
   Если цвет равен 1, то мы нашли цикл
   После цикла присваиваем вершине цвет 2
4. Нахождение диаметра дерева (самый длинный путь)
   Функция maxlen:
      Будем запускать dfs и запоминать расстояния от начальной вершины до всех остальных
      Потом выведем позицию максимума в списке этих расстояний
   Теперь два раза запустим функцию
   Первый раз (v1) от 0
   Второй раз (v2) от v1
   (v1, v2) - это ответ (пара вершин)
5. Поиск компонент связности
   Компонента связности - множество вершин, между каждой парой которых есть путь
   Запустим dfs
   Все вершины, которые он посетил - одна компонента связности
   Запустим из непосещённой вершины, получим ещё одну компоненту
6. Проверка, является ли одна вершина в дереве предком другой
   Для этого будем сохранять времена входа и выхода для каждой вершины
   Вершина v является предком u, если tin[v] <= tin[u] && tout[v] >= tout[u]
