# binsearch

Бинпоиск

Смысл бинпоиска - поиск элемента в отсортированном массиве путём деления массива на две части
Поэтому сложность бинпоиска - log2(n)

Код бинпоиска:
```py
l = 0
r = 10 ** 100
while r - l > 1:
    m = (l + r) // 2
    if f(m) >= x:
        r = m
    else:
        l = m
print(r)
```

f - какая-то функция, x - заданное число

При вещественном бинпоиске (с нецелыми числами, заданная точность) можно заменить while на for
for будет выполняться math.ceil(math.log2((r - l) * 10000000000))
кол-во нулей в последнем числе - точность ответа

Встроенный бинпоиск
Python:
```py
from bisect import bisect_right, bisect_left

a = [1, 2, 4, 5, 6, 6, 7, 9]
ind = bisect_left(a, 5)
ind1 = bisect_right(a, 6)
print(ind, ind1)
```

C++:
```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main() {
	vector<int> a {1, 2, 4, 5, 6, 6, 7, 9};
	int b[7] = { 2, 4, 4, 6, 8, 8, 9 };
	auto it = lower_bound(a.begin(), a.end(), 5);
	cout << *it << ' ' << it - a.begin() << endl;
	auto it1 = upper_bound(b, b + 7, 6);
	cout << *it1 << ' ' << it1 - b << endl;
}
```

bisect_left и lower_bound ищут первый элемент >= заданного
bisect_right и upper_bound ищут первый элемент > заданного

Бинпоиск по ответу
Бинпоиск может быть по ответу
Мы можем применить его, когда функция существования ответа монотонна
Т.е. сначала все ответы не подходят, а потом начинают подходить или наоборот
Возьмём очень маленький ответ. Если он подходит, то будем делать бинпоиск на полуинтервале [l, r), а r будет тем значением, которе не подходит
Иначе бинпоиск на полуинтервале (l, r], l - значение, которое не подходит
Если m подходит, то сдвигаем ту границу, которая включена в полуинтервал