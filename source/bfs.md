# bfs

BFS - поиск в ширину

bfs ищет кратчайшие расстояния от одной вершины до остальных
Код bfs (поиск кратчайшего пути между вершинами a и b + восстановление пути):
```cpp
const int INF = 1e9;
signed main() {
    int n, m, a, b;
    cin >> n >> m >> a >> b;
    a--;
    b--;
    vector<int> g(n);
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        u--;
        v--;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    vector<int> d(n, INF);
    vector<int> p(n, -1);
    queue<int> q;
    q.push(a);
    d[a] = 0;
    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (int u : g[v]) {
            if (d[u] > d[v] + 1) {
                d[u] = d[v] + 1;
                q.push(u);
                p[u] = v;
            }
        }
    }
    if (d[b] == INF) {
        cout << "-1\n";
    }
    else {
        cout << d[b] << el;
        vector<int> ans;
        int cur = b;
        while (cur != -1) {
            ans.push_back(cur + 1);
            cur = p[cur];
        }
        reverse(ans.begin(), ans.end());
        cout << ans << el;
    }
    return 0;
}
```
Важно, что bfs ищет длину кратчайшего пути в РЁБРАХ, поэтому он применяется только на невзвешенных графах
Это связано с самим алгоритмом
Сначала bfs ищет кратчайшие пути длины 1, потом длины 2 и т.д.

У bfs есть модификации:
1. 0-1 BFS
   Если рёбра имеют вес только 0 или 1, то нужно использовать не queue, a deque
   Если ребро имеет вес 0, то нужно добавлять его в начало (push_front), иначе в конец (push_back)
2. 0-k BFS
   BFS может заменить Дейкстру при небольших k
   Мы имеем k+1 очередь, одна из них текущая (расстояние d)
   Если мы находим вершину c расстоянием x, то мы кладём её в очередь с вершинами d+x
   Когда текущая очередь заканчивается, мы переходим в очередь d+1, а прошлая очередь становится максимальной
   Пример:
   Максимум был d+5
   Текущая очередь d закончилась
   Мы переходим в очередь d+1, а прошлая очередь теперь равна d+6