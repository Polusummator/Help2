# matrix_opt

Матричная оптимизация ДП

Матричная оптимизация основана на возведении матрицы в степень
Для этого можно использовать быстрое возведение в степень, которое работает за log (так можно делать, потому что умножение матриц обладает свойством ассоциативности)
Поэтому единственное, что нужно знать - как перемножить две матрицы

Есть две матрицы: a[n][m] и b[l][k]
Их можно перемножить только тогда, когда m = l
Т.е. b[m][k]

Результат умножения - матрица c[n][k]
c[i][j] = sum(a[i][t] * b[t][j]), где 0 <= t <= m - 1

Пример задачи: найти n-ое число Фибоначчи, где n <= 10^18
Хотим из матрицы f(n+1), f(n) получить матрицу f(n + 2), f(n + 1) - матрицы (2, 1)
Такое преобразование можно выполнить, умножив первую матрицу на матрицу ((1, 1), (1, 0))

Код:
```cpp
ll MOD = 1e9 + 7;

// Произведение матриц
vector<vector<ll>> mul(const vector<vector<ll>>& a, const vector<vector<ll>>& b) {
    int n = a.size();
    int m = a[0].size();
    int k = b[0].size();
    vector<vector<ll>> c(n, vector<ll>(k));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < k; j++) {
            for (int q = 0; q < m; q++) {
                c[i][j] += a[i][q] * b[q][j];
                c[i][j] %= MOD;
            }
        }
    }
    return c;
}

vector<vector<ll>> bin_pow(const vector<vector<ll>>& matrix, int n) {
    if (n == 1) {
        return matrix;
    }
    if (n % 2 == 0) {
        auto cur = bin_pow(matrix, n / 2);
        return mul(cur, cur);
    }
    auto cur = bin_pow(matrix, n - 1);
    return mul(cur, matrix);
}

signed main() {
    int n;
    cin >> n;
    if (n == 0) {
        cout << "0\n";
        return 0;
    }
    if (n == 1) {
        cout << "1\n";
        return 0;
    }
    vector<vector<ll>> matrix {{1, 1}, {1, 0}};
    auto res = bin_pow(matrix, n - 1);
    vector<vector<ll>> start {{1}, {1}};
    auto ans = mul(res, start);
    cout << ans[1][0] << el;
    return 0;
}
```

В общем случае мы можем оптимизировать задачи, в которых есть рекуррентное выражение числа dp[i]
Если выражение вида dp[n] = 2 * dp[n - 1] + 10 * dp[n - 3] - 3 * dp[n - 4], то мы будем делать переход
```
dp[n - 1]        dp[n]
dp[n - 2]  --->  dp[n - 1]
dp[n - 3]        dp[n - 2]
dp[n - 4]        dp[n - 3]
```
Матрица, которую мы будем возводить в степень:
```
2, 0, 10, -3
1, 0, 0,   0
0, 1, 0,   0
0, 0, 1,   0
```
Числа в матрице определяются коэффициентами в выражении, т.к. c[i][j] - сумма произведений соответствующих элементов строки первой матрицы и столбца второй матрицы
Т.е. c[0][0] будет равно 2 * dp[n - 1] + 0 * dp[n - 2] + 10 * dp[n - 3] + (-3) * dp[n - 4]
А c[1][0] будет равно 1 * dp[n - 1] + 0 * dp[n - 2] + 0 * dp[n - 3] + 0 * dp[n - 4]