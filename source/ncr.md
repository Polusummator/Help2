# ncr

Кол-во сочетаний

Сочетание из N по K - это набор размера K, выбранный из N элементов (порядок не важен)

Кол-во сочетаний равно биномиальному коэффициенту и может быть вычислено по формуле n! / (k! * (n - k)!)
Чтобы использовать такую формулу, нужно предпосчитать факториалы для всех i: 0 <= i <= n

Кол-во сочетаний можно найти, используя треугольник Паскаля
Тогда C из N по K будут равно значению в N строке (счёт сверху вниз) и в K столбце (счёт слева направо)
Построение треугольника:

```cpp
void f(ull n) {
    tp.resize(n + 1, vector<ull>(n + 1));
    tp[0][0] = 1;
    tp[1][0] = 1;
    tp[1][1] = 1;
    for (int i = 2; i <= n; i++) {
        tp[i][0] = 1;
        for (int j = 1; j < i; j++) {
            tp[i][j] = (tp[i - 1][j - 1] + tp[i - 1][j]) % mod;
        }
        tp[i][i] = 1;
    }
}
```

Существует задача нахождения кол-ва сочетаний по модулю, быстрее, чем за O(n^2), как в предыдущем алгоритме
Для этого используется малая теорема Ферма и обратные элементы по модулю

```cpp
vector<ll> fact;

ull power(ull x, int y) {
    ull res = 1;
    x = x % MOD;
    while (y > 0) {
        if (y & 1)
            res = (res * x) % MOD;
        y = y >> 1;
        x = (x * x) % MOD;
    }
    return res;
}

ull inv(ull n) {
    return power(n, MOD - 2);
}

void build_facts(ull n) {
    fact.resize(n + 1);
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = (fact[i - 1] * i) % MOD;
    }
}

ull get_ncr(ull n, int k) {
    if (n < k) {
        return 0;
    }
    if (k == 0) {
        return 1;
    }
    return (fact[n] * inv(fact[k]) % MOD * inv(fact[n - k]) % MOD) % MOD;
}
```

Сначала нужно предпосчитать факториалы (build_facts), потом ответ на запрос - это вызов функции get_ncr
Это решение находит одно значение C из N по K за O(nlogn)

Если K фиксировано, то можно предпосчитать все inv, но это всё равно будет работать за то же время
Однако если в задаче много запросов на нахождение кол-ва сочетаний, то это улучшит время