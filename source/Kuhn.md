# Kuhn

Алгоритм Куна

Алгоритм Куна - это алгоритм поиска максимального по размеру паросочетания в двудольном графе

Пусть граф уже разбит на две доли
Будем по порядку добавлять вершины первой доли
Если мы можем найти свободную пару для новой вершины, то создадим пару и закончим вызов алгоритма
Если мы не можем найти свободную пару, то попробуем отобрать вершину, соединённую с предыдущей добавленной вершиной
Будем делать это рекурсивно

Код:
```cpp
int n, m; // размеры долей графа
vector<vector<int>> g; // len = n, хранить только для первой доли
vector<int> used; // used[i] - номер последнего запуска алгоритма, в котором i было true
vector<int> pairs; // len = m, сначала заполнен -1


// Если граф задан как обычно
int N;
vector<vector<int>> G;
vector<int> col;
vector<int> col1, col2;

void color(int v, int c) {
    col[v] = c;
    for (int u: G[v]) {
        if (col[u] == -1) {
            color(u, (c + 1) % 2);
        }
    }
}


bool kuhn(int v, int timer) {
    used[v] = timer;
    for (int u: g[v]) {
        if (pairs[u] == -1 || (used[pairs[u]] != timer && kuhn(pairs[u], timer))) {
            pairs[u] = v;
            return true;
        }
    }
    return false;
}

signed main() {
    // input
    // Если input ненормальный (граф задан как обычно):
    col.resize(N, -1);
    color(0, 0);
    for (int i = 0; i < N; i++) {
        if (col[i] == 0) {
            col1.push_back(i);
        }
        else {
            col2.push_back(i);
        }
    }
    n = col1.size();
    m = col2.size();
    g.resize(n);
    for (int i = 0; i < n; i++) {
        g[i] = G[col1[i]];
    }


    pairs.resize(m, -1);
    used.resize(n, -1);
    for (int v = 0; v < n; v++) {
        kuhn(v, v);
    }
    // ответ можно восстановить по pairs
    return 0;
}
```

Применение паросочетаний:
Построим паросочетание на графе
Теперь ориентируем рёбра (если есть в парсоче, то <-, иначе ->)
Запустим dfs из всех ненасыщенных вершин (т.е. из тих, которые не затрагивает паросочетание)
Все вершины разобьются на 4 группы:
L+ - левая доля, посещены dfs
L- - левая доля, не посещены dfs
R+ - правая доля, посещены dfs
R- - правая доля, не посещены dfs

Рёбра между этими группами могут быть только такие:
```
   ---->
L+ <---- R+
         ^
      /
   /
L- ----> R-
   <----
```

1) Минимальное вершинное покрытие = min(L, R, L- + R+) (Мощность мин. покрытия равна мощности макс. паросочетания)
2) Максимальное независимое множество = L+ + R-
Поэтому 1 + 2 = кол-во вершин

ПОКРЫТИЕ ОРИЕНТИРОВАННОГО ГРАФА МИНИМАЛЬНЫМ КОЛ-ВОМ ПУТЕЙ
Продублируем вершины графа (правая доля - копия всех вершин)
Проведём рёбра из левой доли в правую (те рёбра, которые были в исходном графе)
Построим парсоч на этом графе
Теперь проведём обратные рёбра (из вершины 1 правой доли в вершину 1 левой доли, из вершины 2 правой доли в вершину 2 левой доли...)

Будем запускаться из вершин правой доли, которые не покрыты парсочем
Алгоритм таков: переходим по обратному ребру в левую долю,
                если есть ребро паросочетания, то переходим по нему и повторяем алгоритм (так мы считаем один из путей)
                если ребра парсоча нет, то заканчиваем

Код:
```cpp
vector<vector<int>> graph;
vector<int> used;
vector<int> pairs;
int n;

bool Kuhn(int v, int timer) {
    used[v] = timer;
    for (int u : graph[v]) {
        if (pairs[u] == -1 || (used[pairs[u]] != timer && Kuhn(pairs[u], timer))) {
            pairs[u] = v;
            return true;
        }
    }
    return false;
}

signed main() {
    int m;
    cin >> n >> m;
    graph.resize(n);
    pairs.resize(n, -1);
    used.resize(n, -1);
    for (int i = 0; i < m; i++) {
        int v, u;
        cin >> v >> u;
        v--;
        u--;
        graph[v].push_back(u);
    }
    for (int i = 0; i < n; i++) {
        Kuhn(i, i);
    }
    int cnt_paths = 0;
    vector<vector<int>> paths;
    int cur_path = -1;
    for (int i = 0; i < n; i++) {
        if (pairs[i] == -1) {
            cnt_paths++;
            int v = i;
            paths.push_back({});
            cur_path++;
            bool was_edge = false;
            while (true) {
                paths[cur_path].push_back(v + 1);
                was_edge = false;
                for (int u : graph[v]) {
                    if (pairs[u] == v) {
                        v = u;
                        was_edge = true;
                        break;
                    }
                }
                if (!was_edge) {
                    break;
                }
            }
        }
    }
    cout << cnt_paths << el;
    cout << paths << el;
    return 0;
}
```

Антицепь - макс. множество вершин, в котором от любой вершины нельзя добраться до любой другой (в ориентированном графе)
Кол-во вершин в антицепи равно минимальному кол-ву путей, на которые можно разбить граф