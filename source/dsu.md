# dsu

СНМ (Система Непересекающихся Множеств)

СНМ - структура данных, позволяющая объединять множества и считать функции на их объединении
СНМ можно представить в виде графа
У каждого множества есть лидер (к которому напрямую или через другие элементы) подвешиваются элементы множества
Тогда объединение двух множеств - это просто подвешивание лидера одного множества к другому множеству

В приведённом ниже коде используются ранговая эвристика и эвристика сжатия путей
1) Ранговая эвристика: подвешивать лучше меньшее к большему (здесь это производится не по размерам множеств, а по рангам, но сути не меняет)
2) Эвристика сжатия путей: хорошо, когда все вершины подвешены к лидеру напрямую

```cpp
vector<int> p, d;

void init(int n) {
    d.assign(n, 0);
    p.resize(n);
    for (int i = 0; i < n; i++) {
        p[i] = i;
    }
}

int get_par(int v) {
    if (v == p[v]) {
        return v;
    }
    return p[v] = get_par(p[v]);
}

void unite(int v, int u) {
    u = get_par(u);
    v = get_par(v);
    if (u != v) {
        if (d[u] > d[v]) {
            swap(u, v);
        }
        p[u] = v;
        if (d[u] == d[v]) {
            d[v]++;
        }
    }
}
```

Функции на объединении можно считать в unite (можно завести массив значений функций для элементов, как массив d)
Тогда если мы хотим узнать значение функции в множестве, где лежит элемент v, нам нужно найти значение в массиве функции для get_par(v)

СНМ используется в алгоритме Тарьяна (см. lca) и для построения минимального остовного дерева (см. mst)
