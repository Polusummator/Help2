# mst

Минимальное остовное дерево

Минимальное остовное дерево (в взвешенном графе) - это граф, соединяющий все вершины исходного графа и имеющий наименьшую длину
В невзвешенном графе дерево должно иметь наименьшее кол-во рёбер (n - 1)

Лемма о разрезе и критерий Тарьяна:
Разобьём множество вершин графа на любые два множества и построим минимальное остовное дерево
Тогда будут какие-то рёбра на разрезе, соединяющие два множества
Утверждается, что минимальное среди таких рёбер будет принадлежать какому-нибудь минимальному остовному дереву
Допустим, мы не взяли минимальное ребро (v, u), тогда существует другой путь, соединяющий эти две вершины (ведь это дерево)
Пусть этот путь будет проходит через разрез по ребру (x, y)
Теперь, если мы уберём ребро (x, y) и добавим ребро (v, u), то дерево всё равно останется минимальным, потому что ребро (v, u) - минимальное ребро
Критерий Тарьяна звучит так: Остовное дерево минимально тогда и только тогда, когда для любого ребра, не принадлежащего остову, цикл, образуемый этим ребром при добавлении к остову, не содержит рёбер тяжелее этого ребра
Если цикл имеет рёбра больше, то мы можем улучшить ответ, убрав ребро тяжелее текущего и добавив текущее в дерево

Алгоритм Прима:
Алгоритм Прима каждый раз выбирает минимальное ребро, не ведущее в уже построенную компоненту
Код с восстановлением ответа (список рёбер):
```cpp
const int INF = 1e9;
signed main() {
    int n, m;
    cin >> n >> m;
    vector<vector<pair<int, int>>> g(n);
    for (int i = 0; i < m; i++) {
        int v, u, w;
        cin >> v >> u >> w;
        v--;
        u--;
        g[v].push_back({u, w});
        g[u].push_back({v, w});
    }
    vector<int> d(n, INF);
    d[0] = 0;
    set<pair<int, int>> s;
    s.insert({0, 0});
    vector<bool> added(n);
    added[0] = true;
    ll minost = 0;
    vector<int> p(n, -1);
    for (int i = 0; i < n; i++) {
        int v = s.begin()->second;
        minost += s.begin()->first;
        s.erase(s.begin());
        added[v] = true;
        for (auto& k: g[v]) {
            int u = k.first, w = k.second;
            if (added[u]) {
                continue;
            }
            if (d[u] > w) {
                s.erase({d[u], u});
                d[u] = w;
                p[u] = v;
                s.insert({d[u], u});
            }
        }
    }
    cout << minost << el;
    vector<pair<int, int>> ans;
    for (int i = 1; i < n; i++) {
        ans.push_back({i + 1, p[i] + 1});
    }
    for (pair<int, int> p: ans) {
        cout << p.first << ' ' << p.second << el;
    }
    return 0;
}
```

Алгоритм Краскала:
Алгоритм Краскала объединяет ещё не объединённые вершины
Рёбра сортируются по весу и добавляются по одному в СНМ
Код с восстановлением ответа:

```cpp
vector<int> p, d;

void init(int n) {
    d.assign(n, 0);
    p.resize(n);
    for (int i = 0; i < n; i++) {
        p[i] = i;
    }
}

int get_par(int v) {
    if (v == p[v]) {
        return v;
    }
    return p[v] = get_par(p[v]);
}

void unite(int v, int u) {
    u = get_par(u);
    v = get_par(v);
    if (u != v) {
        if (d[u] > d[v]) {
            swap(u, v);
        }
        p[u] = v;
        if (d[u] == d[v]) {
            d[v]++;
        }
    }
}

struct Edge {
    int v, u, w;
    Edge() {}
    Edge(int v_, int u_, int w_): v(v_), u(u_), w(w_) {}
    bool operator<(const Edge& a) const {
        return w < a.w;
    }
};

signed main() {
    int n, m;
    cin >> n >> m;
    vector<Edge> edges;
    for (int i = 0; i < m; i++) {
        int v, u, w;
        cin >> v >> u >> w;
        v--;
        u--;
        edges.push_back(Edge(v, u, w));
    }
    init(n);
    sort(edges.begin(), edges.end());
    ll minost = 0;
    vector<Edge> ans;
    for (const Edge& e: edges) {
        if (get_par(e.v) != get_par(e.u)) {
            unite(e.v, e.u);
            minost += e.w;
            ans.push_back(e);
        }
    }
    cout << minost << el;
    for (const Edge& e: ans) {
        cout << e.v + 1 << ' ' << e.u + 1 << el;
    }
    return 0;
}
```

В конце нужно проверить, сколько рёбер в структуре. Если кол-во рёбер != n - 1, то граф несвязный, остовное дерево не построено

Также можно строить несколько минимальных остовных деревьев
Сначала нужно построить минимальное дерево, а потом в цикле убирать по одному (или больше, если нужно много деревьев) ребру из дерева и заменять его другим в списке рёбер
В конце нужно проверять существование нового остовного дерева (написано выше)